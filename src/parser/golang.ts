import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

function hexlify (str:string): string {
  return str.split('')
    .map(ch => '0x' + ch.charCodeAt(0).toString(16))
    .join(', ')
}

export class GoParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"pgm":3,"TYPE":4,"Id":5,"StructType":6,"EOF":7,"STRUCT":8,"LBRACE":9,"FieldList":10,"RBRACE":11,"Field":12,"SEMICOLON":13,"IdList":14,"Type":15,"Tag":16,"IDENT":17,"COMMA":18,"STRING":19,"BSTRING":20,"TypeName":21,"TypeLit":22,"LPAREN":23,"RPAREN":24,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",4:"TYPE",7:"EOF",8:"STRUCT",9:"LBRACE",11:"RBRACE",13:"SEMICOLON",17:"IDENT",18:"COMMA",19:"STRING",20:"BSTRING",23:"LPAREN",24:"RPAREN"};
    productions_: ProductionsType = [0,[3,4],[6,4],[10,1],[10,2],[10,2],[10,3],[12,3],[12,2],[5,1],[14,1],[14,3],[16,1],[16,1],[15,1],[15,1],[15,3],[21,1],[22,1]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {7:[2,1],15:[2,5],23:[2,6]};

    constructor (yy = {}, lexer = new GoLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[1,4],$V1=[1,6],$V2=[1,19],$V3=[8,17,23],$V4=[11,13,17],$V5=[11,13,17,19,20,24];
      const o = JisonParser.expandParseTable;
      this.table = [{3:1,4:[1,2]},{1:[3]},{5:3,17:$V0},{6:5,8:$V1},o([8,11,13,17,18,19,20,23,24],[2,9]),{7:[1,7]},{9:[1,8]},{1:[2,1]},{5:12,10:9,12:10,14:11,17:$V0},{11:[1,13]},{5:12,10:15,11:[2,3],12:10,13:[1,14],14:11,17:$V0},{5:20,6:21,8:$V1,15:16,17:$V0,21:17,22:18,23:$V2},o($V3,[2,10],{18:[1,22]}),o([7,11,13,17,19,20,24],[2,2]),{5:12,10:23,11:[2,4],12:10,14:11,17:$V0},{11:[2,5]},o($V4,[2,8],{16:24,19:[1,25],20:[1,26]}),o($V5,[2,14]),o($V5,[2,15]),{5:20,6:21,8:$V1,15:27,17:$V0,21:17,22:18,23:$V2},o($V5,[2,17]),o($V5,[2,18]),{5:12,14:28,17:$V0},{11:[2,6]},o($V4,[2,7]),o($V4,[2,12]),o($V4,[2,13]),{24:[1,29]},o($V3,[2,11]),o($V5,[2,16])];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 if (yy.trace) yy.trace('returning', $$[$0-3]);
          return "type " + $$[$0-2] + " " + $$[$0-1] 
break;
case 2:
this.$ = "struct {" + $$[$0-1] + " }" ;
break;
case 3:
this.$ = $$[$0] + "; "
break;
case 4:
this.$ = $$[$0-1] + "; "
break;
case 5:
this.$ = $$[$0-1] + "; " + $$[$0]
break;
case 6:
this.$ = $$[$0-2] + "; " + $$[$0]
break;
case 7:
this.$ = $$[$0-2] + " " + $$[$0-1] + " " + $$[$0]
break;
case 8:
this.$ = $$[$0-1] + " " + $$[$0]
break;
case 9: case 12: case 13: case 17:
this.$ = yytext
break;
case 10: case 14: case 15: case 18:
this.$ = $$[$0]
break;
case 11:
this.$ = $$[$0-2] + ", " + $$[$0]
break;
case 16:
this.$ = $$[$0-1]
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class GoLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"Go"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:\/\/.*)/,
        /^(?:[\s\t]+)/,
        /^(?:struct\b)/,
        /^(?:type\b)/,
        /^(?:\{)/,
        /^(?:\})/,
        /^(?:\()/,
        /^(?:\))/,
        /^(?:\[)/,
        /^(?:\])/,
        /^(?:;)/,
        /^(?:,)/,
        /^(?:\.)/,
        /^(?:")/,
        /^(?:[^\"\n]+)/,
        /^(?:")/,
        /^(?:`)/,
        /^(?:[^"`"\n]+)/,
        /^(?:`)/,
        /^(?:[a-zA-Z_][a-zA-Z0-9]*)/,
        /^(?:$)/
    ];
    conditions: any = {"STRING":{"rules":[14,15],"inclusive":false},"BSTRING":{"rules":[17,18],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,16,19,20],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:/* ignore comment */
      break;
    case 1:if (yy.trace) yy.trace(`skipping whitespace ${hexlify(yy_.yytext)}`)
      break;
    case 2:return 8
    case 3:return 4
    case 4:return 9
    case 5:return 11
    case 6:return 23
    case 7:return 24
    case 8:return 'LBRACKET'
    case 9:return 'RBRACKET'
    case 10:return 13;
    case 11:return 18;
    case 12:return 'DOT';
    case 13:this.begin('STRING');  this.more();
      break;
    case 14:this.more();
      break;
    case 15:this.begin('INITIAL'); return 19; 
    case 16:this.begin('BSTRING');  this.more();
      break;
    case 17:this.more();
      break;
    case 18:this.begin('INITIAL'); return 20;
    case 19:return 17
    case 20:return 7
        }
    }
}


