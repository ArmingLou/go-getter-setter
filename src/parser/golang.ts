import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

function hexlify (str:string): string {
  return str.split('')
    .map(ch => '0x' + ch.charCodeAt(0).toString(16))
    .join(', ')
}

export class GoParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"pgm":3,"TYPE":4,"Id":5,"StructType":6,"EOF":7,"TypeParameters":8,"STRUCT":9,"LBRACE":10,"FieldList":11,"RBRACE":12,"Field":13,"SEMICOLON":14,"IdList":15,"Type":16,"Tag":17,"IDENT":18,"COMMA":19,"STRING":20,"BSTRING":21,"LBRACKET":22,"TypeParamList":23,"RBRACKET":24,"TypeParamDecl":25,"TypeConstraint":26,"TypeElem":27,"TypeTerm":28,"VARTICALBAR":29,"UnderlyingType":30,"TILDE":31,"TypeName":32,"TypeArgs":33,"TypeLit":34,"LPAREN":35,"RPAREN":36,"QualifiedIdent":37,"TypeList":38,"ArrayType":39,"PointerType":40,"SliceType":41,"MapType":42,"ElementType":43,"MAP":44,"ArrayLength":45,"INT":46,"ASTER":47,"BaseType":48,"DOT":49,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",4:"TYPE",7:"EOF",9:"STRUCT",10:"LBRACE",12:"RBRACE",14:"SEMICOLON",18:"IDENT",19:"COMMA",20:"STRING",21:"BSTRING",22:"LBRACKET",24:"RBRACKET",29:"VARTICALBAR",31:"TILDE",35:"LPAREN",36:"RPAREN",44:"MAP",46:"INT",47:"ASTER",49:"DOT"};
    productions_: ProductionsType = [0,[3,4],[3,5],[6,4],[11,1],[11,2],[11,2],[11,3],[13,3],[13,2],[5,1],[15,1],[15,3],[17,1],[17,1],[8,3],[8,4],[23,1],[23,3],[25,2],[26,1],[27,1],[27,3],[28,1],[28,1],[30,2],[16,1],[16,2],[16,1],[16,3],[32,1],[32,1],[33,3],[33,4],[38,1],[38,3],[34,1],[34,1],[34,1],[34,1],[34,1],[41,3],[42,5],[39,4],[45,1],[43,1],[40,2],[48,1],[37,3]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {9:[2,1],16:[2,2],20:[2,15],44:[2,6],46:[2,16],56:[2,44],61:[2,7]};

    constructor (yy = {}, lexer = new GoLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[1,4],$V1=[1,7],$V2=[19,24],$V3=[1,38],$V4=[1,30],$V5=[1,29],$V6=[1,40],$V7=[1,39],$V8=[9,18,22,31,35,44,47],$V9=[19,24,29],$Va=[12,14,18,19,20,21,24,29,36],$Vb=[12,14,18,19,20,21,22,24,29,36],$Vc=[12,14,18];
      const o = JisonParser.expandParseTable;
      this.table = [{3:1,4:[1,2]},{1:[3]},{5:3,18:$V0},{6:5,8:6,9:$V1,22:[1,8]},o([9,12,14,18,19,20,21,22,24,29,31,35,36,44,47,49],[2,10]),{7:[1,9]},{6:10,9:$V1},{10:[1,11]},{5:15,15:14,18:$V0,23:12,25:13},{1:[2,1]},{7:[1,16]},{5:15,11:17,13:18,15:19,18:$V0},{19:[1,21],24:[1,20]},o($V2,[2,17]),{5:31,6:34,9:$V1,16:25,18:$V0,22:$V3,26:22,27:23,28:24,30:26,31:$V4,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},o($V8,[2,11],{19:[1,41]}),{1:[2,2]},{12:[1,42]},{5:15,11:44,12:[2,4],13:18,14:[1,43],15:19,18:$V0},{5:31,6:34,9:$V1,16:45,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},{9:[2,15]},{5:15,15:14,18:$V0,24:[1,46],25:47},o($V2,[2,19]),o($V2,[2,20],{29:[1,48]}),o($V9,[2,21]),o($V9,[2,23]),o($V9,[2,24]),o($Va,[2,26],{33:49,22:[1,50]}),o($Va,[2,28]),{5:31,6:34,9:$V1,16:51,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},{5:31,6:34,9:$V1,16:52,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},o($Vb,[2,30],{49:[1,53]}),o($Vb,[2,31]),o($Va,[2,36]),o($Va,[2,37]),o($Va,[2,38]),o($Va,[2,39]),o($Va,[2,40]),{24:[1,55],45:54,46:[1,56]},{5:31,6:34,9:$V1,16:58,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7,48:57},{22:[1,59]},{5:15,15:60,18:$V0},o([7,12,14,18,19,20,21,24,29,36],[2,3]),{5:15,11:61,12:[2,5],13:18,15:19,18:$V0},{12:[2,6]},o($Vc,[2,9],{17:62,20:[1,63],21:[1,64]}),{9:[2,16]},o($V2,[2,18]),{5:31,6:34,9:$V1,16:25,18:$V0,22:$V3,28:65,30:26,31:$V4,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},o($Va,[2,27]),{5:31,6:34,9:$V1,16:67,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,38:66,39:33,40:35,41:36,42:37,44:$V6,47:$V7},{36:[1,68]},o($V9,[2,25]),{5:69,18:$V0},{24:[1,70]},{5:31,6:34,9:$V1,16:72,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,43:71,44:$V6,47:$V7},{24:[2,44]},o($Va,[2,46]),o($Va,[2,47]),{5:31,6:34,9:$V1,16:73,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},o($V8,[2,12]),{12:[2,7]},o($Vc,[2,8]),o($Vc,[2,13]),o($Vc,[2,14]),o($V9,[2,22]),{19:[1,75],24:[1,74]},o($V2,[2,34]),o($Va,[2,29]),o($Vb,[2,48]),{5:31,6:34,9:$V1,16:72,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,43:76,44:$V6,47:$V7},o($Va,[2,41]),o($Va,[2,45]),{24:[1,77]},o($Va,[2,32]),{5:31,6:34,9:$V1,16:79,18:$V0,22:$V3,24:[1,78],32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,44:$V6,47:$V7},o($Va,[2,43]),{5:31,6:34,9:$V1,16:72,18:$V0,22:$V3,32:27,34:28,35:$V5,37:32,39:33,40:35,41:36,42:37,43:80,44:$V6,47:$V7},o($Va,[2,33]),o($V2,[2,35]),o($Va,[2,42])];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 if (yy.trace) yy.trace('returning', $$[$0-3]);
          return "type " + $$[$0-2] + " " + $$[$0-1] 
break;
case 2:
 if (yy.trace) yy.trace('returning', $$[$0-4]);
          return "type " + $$[$0-3] + " " + $$[$0-2] + " " + $$[$0-1] 
break;
case 3:
this.$ = "struct {" + $$[$0-1] + " }" ;
break;
case 4:
this.$ = $$[$0] + "; "
break;
case 5:
this.$ = $$[$0-1] + "; "
break;
case 6:
this.$ = $$[$0-1] + "; " + $$[$0]
break;
case 7:
this.$ = $$[$0-2] + "; " + $$[$0]
break;
case 8:
this.$ = $$[$0-2] + " " + $$[$0-1] + " " + $$[$0]
break;
case 9: case 19:
this.$ = $$[$0-1] + " " + $$[$0]
break;
case 10: case 13: case 14: case 44:
this.$ = yytext
break;
case 11: case 17: case 20: case 21: case 23: case 24: case 26: case 28: case 30: case 31: case 34: case 36: case 37: case 38: case 39: case 40: case 45: case 47:
this.$ = $$[$0]
break;
case 12: case 35:
this.$ = $$[$0-2] + ", " + $$[$0]
break;
case 15: case 32:
this.$ = "[" + $$[$0-1] + "]"
break;
case 16: case 33:
this.$ = "[" + $$[$0-2] + "]"
break;
case 18:
this.$ = $$[$0-2] + " , " + $$[$0]
break;
case 22:
this.$ = $$[$0-2] + " | " + $$[$0]
break;
case 25: case 27:
this.$ = $$[$0-1] + $$[$0]
break;
case 29:
this.$ = $$[$0-1]
break;
case 41:
this.$ = "[]" + $$[$0]
break;
case 42:
this.$ = "map[" + $$[$0-2] + "]" + $$[$0]
break;
case 43:
this.$ = "[" + $$[$0-2] + "]" + $$[$0]
break;
case 46:
this.$ = "*" + $$[$0]
break;
case 48:
this.$ = $$[$0-2] + "." + $$[$0]
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class GoLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"Go"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:\/\/.*)/,
        /^(?:[\s\t]+)/,
        /^(?:struct\b)/,
        /^(?:type\b)/,
        /^(?:map\b)/,
        /^(?:\{)/,
        /^(?:\})/,
        /^(?:\()/,
        /^(?:\))/,
        /^(?:\[)/,
        /^(?:\])/,
        /^(?:;)/,
        /^(?:\|)/,
        /^(?:\*)/,
        /^(?:~)/,
        /^(?:,)/,
        /^(?:\.\.\.)/,
        /^(?:\.)/,
        /^(?:")/,
        /^(?:[^\"\n]+)/,
        /^(?:")/,
        /^(?:`)/,
        /^(?:[^"`"\n]+)/,
        /^(?:`)/,
        /^(?:[a-zA-Z_][a-zA-Z0-9]*)/,
        /^(?:0[0-9]*)/,
        /^(?:[0]|[1-9][0-9]*)/,
        /^(?:$)/
    ];
    conditions: any = {"STRING":{"rules":[19,20],"inclusive":false},"BSTRING":{"rules":[22,23],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,21,24,25,26,27],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:/* ignore comment */
      break;
    case 1:if (yy.trace) yy.trace(`skipping whitespace ${hexlify(yy_.yytext)}`)
      break;
    case 2:return 9
    case 3:return 4
    case 4:return 44
    case 5:return 10
    case 6:return 12
    case 7:return 35
    case 8:return 36
    case 9:return 22
    case 10:return 24
    case 11:return 14;
    case 12:return 29;
    case 13:return 47;
    case 14:return 31;
    case 15:return 19;
    case 16:return 'DOTDOTDORT';
    case 17:return 49;
    case 18:this.begin('STRING');  this.more();
      break;
    case 19:this.more();
      break;
    case 20:this.begin('INITIAL'); return 20; 
    case 21:this.begin('BSTRING');  this.more();
      break;
    case 22:this.more();
      break;
    case 23:this.begin('INITIAL'); return 21;
    case 24:return 18
    case 25:throw 'integer must be [0]|([1-9][0-9]*)'
      break;
    case 26:return 46
    case 27:return 7
        }
    }
}


